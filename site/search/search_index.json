{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"audio_signal","text":"<p>Welcome to the documentation for <code>audio_signal</code>!</p> <p>A modern Python library for audio signal processing, built on PyTorch and torchaudio.</p> <ul> <li>Installation</li> <li>Usage</li> <li>API Reference</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#audio_signal.core.CoreAudioSignal","title":"<code>CoreAudioSignal</code>","text":"<p>               Bases: <code>Tensor</code></p> <p>A low-level subclass of torch.Tensor that represents an audio signal with an attached sample rate. Supports initialization from various formats (file path, numpy array, torch tensor),</p> Source code in <code>src/audio_signal/core.py</code> <pre><code>class CoreAudioSignal(torch.Tensor):\n    \"\"\"\n    A low-level subclass of torch.Tensor that represents an audio signal with an attached sample rate.\n    Supports initialization from various formats (file path, numpy array, torch tensor),\n    \"\"\"\n    def __new__(cls,\n                audio_source: Union[torch.Tensor, np.ndarray, str, bytes],\n                sample_rate: int = None):\n\n        if isinstance(audio_source, cls):\n            return audio_source\n\n        inferred_sr = None\n        if isinstance(audio_source, (str, bytes)):\n            audio_source, inferred_sr = ta.load(audio_source)\n\n        elif isinstance(audio_source, np.ndarray):\n            audio_source = torch.from_numpy(audio_source)\n\n        elif isinstance(audio_source, torch.Tensor):\n            if sample_rate is None and hasattr(audio_source, '_sample_rate'):\n                sample_rate = audio_source._sample_rate\n        else:\n            raise TypeError(f'Unsupported input data type: {type(audio_source)}')\n\n        if sample_rate is None:\n            if inferred_sr is None:\n                raise ValueError('Sample rate must be provided')\n            else:\n              sample_rate = inferred_sr\n\n        obj = torch.Tensor(audio_source).as_subclass(cls)\n        obj._sample_rate = sample_rate\n\n        if inferred_sr is not None and inferred_sr!=sample_rate:\n            warnings.warn(f'Inferred sample rate {inferred_sr} does not match provided sample rate {sample_rate}')\n            obj = obj.resample(sample_rate)\n\n        return obj\n\n    @property\n    def sample_rate(self):\n        return self._sample_rate\n\n\n    def resample(self, new_sample_rate):\n        result =  ta.transforms.Resample(self.sample_rate, new_sample_rate)(self)\n        return type(self)(result,new_sample_rate)\n\n    @classmethod\n    def __torch_function__(cls, func, types, args=(), kwargs=None):\n        if kwargs is None:\n            kwargs = {}\n\n        result = super().__torch_function__(func, types, args, kwargs)\n\n        # This is a tricky part - Based on the result of the function we\n        # should decide whether to return a CoreAudioSignal or not.\n\n        if not isinstance(result, CoreAudioSignal):\n            return result\n\n        if result.is_complex() or result.ndim not in (1,2):\n            return result.as_subclass(torch.Tensor)\n\n        if result.ndim == 2 and result.shape[0] not in (1,2):\n            return result.as_subclass(torch.Tensor)\n\n        # find a source with sample rate\n        def find_sr(obj):\n            return getattr(obj, '_sample_rate', None)\n\n        # look in args\n        sr = None\n        all_args = list(args)\n        if args and isinstance(args[0], (tuple, list)):\n            all_args += list(args[0])\n\n        for arg in all_args:\n            if isinstance(arg, CoreAudioSignal):\n                sr = find_sr(arg)\n                if sr is not None:\n                    break\n\n        # propagate sample_rate if result is tensor-like\n        if sr is None:\n          return result.as_subclass(torch.Tensor)\n\n        result._sample_rate = sr\n        return result\n\n    def _from_tensor(self,tensor):\n      return type(self)(tensor,self._sample_rate)\n\n    def clone(self):\n        return self._from_tensor(super().clone())\n\n    def __repr__(self):\n        return super().__repr__() + f', sample_rate={self.sample_rate}'\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>We recommend using uv for fast dependency management:</p> <pre><code>uv pip install audio_signal\n</code></pre> <p>Or with pip:</p> <pre><code>pip install audio_signal\n</code></pre>"},{"location":"usage/","title":"Usage Examples","text":""},{"location":"usage/#generate-and-play-a-sine-wave","title":"Generate and play a sine wave","text":"<pre><code>from audio_signal import AudioSignal\nsig = AudioSignal.wave(freq=440, time=2, sr=16000)\nsig.play()\n</code></pre>"},{"location":"usage/#load-from-file","title":"Load from file","text":"<pre><code>sig = AudioSignal('audio.wav', sample_rate=16000)\n</code></pre>"}]}